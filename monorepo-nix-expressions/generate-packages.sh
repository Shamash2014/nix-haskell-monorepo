#!/usr/bin/env bash

# TODO log absolute paths

CODE_ROOT="$1"

echo "Clearing folder ./packages/"
mkdir ./packages || true
rm ./packages/* || true

declare -a PKGS

# TODO use builtin nix functions to list directory contents instead of generating the attribute sets
echo "# DO NOT MODIFY ! - this file is generated by generate-packages.sh " > packages.nix
echo "{" > packages.nix

# TODO use cabal.project file instead of recursively searching *.cabal files.
for row in $(grep -R --include '*.cabal' --exclude-dir '.stack-work' '^name:' "$CODE_ROOT" | sed 's/:name:\s*/:/'); do
  cf="$(echo $row | cut -d: -f1)"
  CABAL_FILE_DIR="$(dirname "$cf")"
  PACKAGE_NAME="$(echo $row | cut -d: -f2)"

  printf "Generating cabal for package: %s (dir: %s)\n" "$PACKAGE_NAME" "$CABAL_FILE_DIR"
  (cd packages && cabal2nix ../$CABAL_FILE_DIR > ./${PACKAGE_NAME}.nix)

  PKGS+=("$PACKAGE_NAME")
  echo "    ${PACKAGE_NAME} = import ./packages/${PACKAGE_NAME}.nix;" >> packages.nix
done

echo "}" >> packages.nix

cat > hydra.nix <<EOF
# DO NOT MODIFY ! - this file is generated by generate-packages.sh
let
    nixpkgs = import ./release.nix;

    doHaddock = nixpkgs.haskell.lib.doHaddock;
    doCoverage = nixpkgs.haskell.lib.doCoverage;
    mapAttrs = nixpkgs.lib.mapAttrs;

in mapAttrs (name: value: doHaddock (doCoverage value))
{
    inherit (nixpkgs.haskellPackages)
$(echo "${PKGS[@]}" | fmt -w 80 | sed 's/^/        /');
}
EOF
